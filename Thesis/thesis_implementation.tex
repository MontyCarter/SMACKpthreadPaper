\chapter{Implementation}\label{ch:implementation}
[Whole chapter is really, really terrible writing, but roughly
representative of the final content and organization]
With the pthread model starting to take shape, the next step in my
research was to look forward and consider the actual implementation of
phtread library support as part of the SMACK verifier.  This chapter
provides an overview of the actual implementation of the pthread
libarary extension to SMACK.  First I introduce the actual
implementation goal for the pthread extension to SMACK, and proceed to
describe the implementation.  The chapter concludes with a description
of the final state of the implementation with respect to its goals.

\section{Implementation Goals}
If the exact behavior of the pthread library were modeled, it wouldn't
be much of a model.  Instead, it would make more sense to completely
model the environment presented by the operating system, down to the
system calls used to spawn threads and query for thread IDs, and
simply treat the pthread library as part of the input program to be
verified. This is an unreasonable approach, however, as the resulting
Boogie translation would be far more computationally expensive, and
require modeling far more OS level system calls than are in the
pthread library to begin with.

A more reasonable approach, and the one adopted as my implementation
goal,  is to model the most commonly utilized functionality in the
pthread library.  This was assessed using benchmarks from the SVCOMP
software verification competition [add Inspect and CIVL to this list
of benchmark sources].  A count of the number of calls to
each function in the pthread API was generated by scanning all of the
benchmarks from the pthread category used in the SVCOMP verification
competition.  The most commonly occurring function calls were
prioritized for modeling for the implementation.

[Maybe talk about attributes, thread local data, error handling, etc
(that is, general categories - not specific functions) not making the
cut] 

\section{[wc Including the pthread Model]}
As mentioned in Section~\ref{sec:modelingenvironment}, libraries
included by input programs are not typically linked when SMACK
generates LLVM bytecode.  The functions declared in these library
headers go undefined, and SMACK model's their behavior as returning a
nondeterministic value, though not affecting program state.  Before
pthread support was added to SMACK, the pthread library was no
different in this regard.  SMACK would call to
\lstinline|pthread_create()| as simply returning a nondeterministic
integer.

Adding a model to SMACK is as simple as providing a definition for the
undefined functions declared in the library headers.  Before providing
definitions for such functions, while evaluating the LLVM IR SMACK
encounters a call to an externally defined function, and simply
returns a nondeterministic value.  Once a definition has been
provided, however, SMACK will find the function definition and
translate the function definition as well, which causes the function
to use its modeled semantics, including modifications to program
state,  rather than returning a nondeterministic value.

These function definitions can be to the input C/C++ program the same
way that externally defined functionality is added to any C/C++
program: header files are included to declare the functions, and the
definitions contained in the compiled library are resolved by the
linker.  Linking all libraries included by input programs would bring
SMACK to its feet, as it would potentially have to model [wc the whole
GNU library (something large and unreasonable here)].  However,
strategically linking replacement libraries that model the behavior of
the original library allows SMACK to [wc digest] much simpler code
that captures the essence of the original library's behavior.  [In
addition, verification conditions not typically found in original
source libraries can be included in the replacement library model,
providing the ability to check extra conditions.  - This is bullshit,
I feel - probably take out]

This strategy of providing a replacement library that contains a model
of the original library is precisely how the pthread library model
discussed in Chapter~\ref{ch:modeldesign} was added to SMACK.  When
SMACK calls Clang, it passes the \emph{-I} switch with the path to the
replacement pthread.h.  The causes the SMACK version of pthread.h to
be included, rather than searching the default include paths.  With
our declarations of the pthread API included, the resulting [object
file] is linked with our version of pthread.bc containing the function
definitions containing our model of the pthread API.  As a result, the
AST seen by SMACK during translation to Boogie contains the models
described in Chapter~\ref{ch:modeldesign}.

\section{SMACK Modification?}
[Do a section here on init funcs?]

In addition to linking the pthread model during compilation of LLVM IR
bytecode, there were[are?] two additional problems related to LLVM IR
to Boogie translation [how to say smack itself?] that needed to be
addressed.

The first problem is related to the initialization of the
\lstinline|$pthreadStatus| array, which sets all threads to an
\emph{uninitialized} state, as described in
Section~\ref{sec:osenvironmentorwhatever}.  This initialization must
be performed from a within a call to a function, as neither C/C++ nor
Boogie allow statements to be executed in the global declaration
scope.  To ensure this initialization happens before any code other
input program code is evaluated, this initialization of
\lstinline|$pthreadStatus| must be injected as the first statement in
\lstinline|main()|.  This required extending SMACK itself with an
additional C level Boogie injection function, similar to those
described in Section~\ref{whatever}.  The added functionality causes
SMACK to search for function definitions whose function name starts
with \lstinline|__SMACK_init_func_|.  Any such function definition
encountered while parsing the AST causes SMACK to insert a call to the
function as the first line of \lstinline|main()|.  This allows such
functions to be defined in modeled libraries, rather than having to
modify the source of each input program requiring such an
initialization.  It is using this new functionality that
\lstinline|$pthreadStatus| is initialized.

The second problem is the ability of a function call to inform SMACK
that the thread of execution is stopping, such as with the
\lstinline|exit()| system call, or \lstinline|pthread_exit()|.  As
with modeling the operating system environment's thread ID coordination,
terminating a thread of execution is similarly the operating system's
responsibility.  When the operating system receives the
\lstinline|exit()| system call, it proceeds to swap out the process,
and mark it as \emph{stopped}.  There is no Boogie IVL instruction for
this, so it must be modeled.  There are several proposals for
addressing this, but it currently remains unimplemented.

\section{[wc Implemented Functionality]}
Currently, there are 15 pthread API calls modeled in the pthread
extension to SMACK.  These 15 calls represent 2959 of 3257 -- roughly
91\% -- of all pthread API calls found in the SVCOMP, Inspect, and
CIVL benchmarks. [Some of the missing 300 come from input programs
that define functions with names starting with ``pthread''...]

In its present form, the pthread extension to SMACK models the
following pthread API calls:

\begin{itemize}
\item \lstinline|pthread_create()|
\item \lstinline|pthread_self()|
\item \lstinline|pthread_exit()|
\item \lstinline|pthread_join()|
\item \lstinline|pthread_mutex_init()|
\item \lstinline|pthread_mutexattr_init()|
\item \lstinline|pthread_mutexattr_settype()|
\item \lstinline|pthread_mutex_lock()|
\item \lstinline|pthread_mutex_unlock()|
\item \lstinline|pthread_mutex_destroy()|
\item \lstinline|pthread_cond_init()|
\item \lstinline|pthread_cond_wait()|
\item \lstinline|pthread_cond_signal()|
\item \lstinline|pthread_cond_broadcast()|
\item \lstinline|pthread_cond_destroy()|
\end{itemize}

With a vast majority of pthread calls modeled, the pthread extension
to SMACK is certainly ready for experimental use, and even with
real-world programs that don't fully utilize the pthread API.




[leftover from intro]


[Remaining is leftover stuff -- may be useful when revising intro]
This is supported by the accuracy seen in the empirical results of
initial implementation testing.  My proposed research will extend
SMACK with a model of a common subset of the pthreads API, enabling
verification of C/C++ programs utilizing the Pthreads library.
Extending SMACK to provide support for programs using pthreads has not
only provided the SMACK community with support for a common
concurrency paradigm, but also presents an opportunity to investigate
general constructs useful for modeling concurrency.  These constructs,
which will necessarily result from extending SMACK, will lend
themselves to modeling other concurrency libraries like OpenMP and
MPI.  Further, the resulting constructs should be general enough for
use within other verification tools. 

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 
